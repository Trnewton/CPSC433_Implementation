package SetBased;

/*
 * Implementation of a set-based genetic search algorithm for sceduling classes into timeslots
 */


import OrTree.OTreeModel;
import Structures.*;
import Parser.Reader;
import Structures.Assignment;
import Structures.Course;
import static java.lang.Math.abs;

import java.util.*;

public class SetBased {

    private ArrayList<Fact> facts;
    private float threshold;
    private double difTol;
    private int maxPopulation;
    private Reader reader;
    private OTreeModel oTree;
    private Set<Course> courseLab;
    private int maxInitSols;
    private int variance;
    private float firMoment;
    private float secMoment;
    private final float wMinFill;
    private final float wPref;
    private final float wPair;
    private final float wSecDiff;
    private final float pen_CourseMin;
    private final float pen_LabMin;
    private final float pen_Pair;
    private final float pen_Section;
    private String fileName;
    private double killPercent;
    private boolean output;

    public SetBased(Reader reader, OTreeModel oTree, float[] weights, String fileName, boolean output) {
        //Initialize the SetBased environment
        this.fileName = fileName;
        this.threshold = (float) 5;
        this.killPercent = 0.30;
        this.difTol = 0.05;
        this.maxPopulation = 50;
        this.facts = new ArrayList();
        this.reader = reader;
        this.oTree = oTree;
        this.courseLab = new LinkedHashSet(reader.getCourses());
        this.courseLab.addAll(reader.getLabs());
        this.maxInitSols = 15;
        this.variance = Integer.MAX_VALUE;
        this.firMoment = 0;
        this.secMoment = 0;
        this.wMinFill = weights[0];
        this.wPref = weights[1];
        this.wPair = weights[2];
        this.wSecDiff = weights[3];
        this.output = output;
        if(weights.length==8){
            this.pen_CourseMin = weights[4];
            this.pen_LabMin = weights[5];
            this.pen_Pair = weights[6];
            this.pen_Section = weights[7];
        } else {
            this.pen_CourseMin = 1;
            this.pen_LabMin = 1;
            this.pen_Pair = 1;
            this.pen_Section = 1;
        }
    }
    
    //Performs a mutation from a randomly selected solution from the current state.
    //Precondition: There are existing solutions in the current state
    //Postcondition: Adds a new solution to the current state that was generated by 
    //               specifically making a different decision than the parent solution
    //               but otherwise trying to remain as similar to the parent as possible
    private Fact Mutation(){
        Random random = new Random();

        //Create a Deep Copy of a random Fact, then getSChedule()
        Fact mutFact = new Fact(facts.get(random.nextInt(facts.size() - 1)));
        Map<Course, Slot> mutSchedule = mutFact.getScheduel();

        // Get a random lecture (lab or lecture) from scheduel
        Course mutCourse = mutSchedule.keySet().toArray(new Course[0])[random.nextInt(mutSchedule.size() - 1)];
        Slot newSlot;
        // Make sure new slot for mutCourse is of right type and is different
        if (mutCourse instanceof Lecture) { // Lecture
            newSlot = reader.getCourseSlots().toArray(new Slot[0])[random.nextInt(reader.getCourseSlots().size() - 1)];
            while (newSlot.equals(mutSchedule.get(mutCourse))) {
                newSlot = reader.getCourseSlots().toArray(new Slot[0])[random.nextInt(reader.getCourseSlots().size() - 1)];
            }
        } else { // Lab
            newSlot = reader.getLabSlots().toArray(new Slot[0])[random.nextInt(reader.getLabSlots().size() - 1)];
            while (newSlot.equals(mutSchedule.get(mutCourse))) {
                newSlot = reader.getLabSlots().toArray(new Slot[0])[random.nextInt(reader.getLabSlots().size() - 1)];
            }
        }
        // Remove lecture from lectures
        mutSchedule.remove(mutCourse);
        // Create arraylist for guide and create iterator to add non-changed assigns
        ArrayList<Assignment> guide = new ArrayList(mutSchedule.size());
        guide.add(new Assignment(mutCourse, newSlot));
        Iterator<Map.Entry<Course, Slot>> itor = mutSchedule.entrySet().iterator();

        while (itor.hasNext()) {
            Map.Entry<Course, Slot> entry = itor.next();
            guide.add(new Assignment(entry.getKey(), entry.getValue()));
        }

        Fact newFact = (Fact) oTree.guided(guide);
        if (newFact != null) {
            newFact.setEvaluation(Eval(newFact));
        }

        return newFact;
    }
    
    //Performs a combination from two randomly selected solutions from the current state.
    //Precondition: There are at least 2 existing solutions in the current state
    //Postcondition: Adds two new solutions to the current state that was generated by 
    //               copying a section of random length from each parent and then filling
    //               the remainder of the solution to be as similar as possible to the other
    //               parent.
    private Fact[] Combination(){
        Random rand = new Random();

        HashMap<Course, Slot> p1Map = new HashMap(facts.get(rand.nextInt(facts.size() - 1)).getScheduel());
        HashMap<Course, Slot> p2Map = new HashMap(facts.get(rand.nextInt(facts.size() - 1)).getScheduel());
        while (p2Map.equals(p1Map)) {
            p2Map = new HashMap(facts.get(rand.nextInt(facts.size() - 1)).getScheduel());
        }

        ArrayList<Assignment> guide1 = new ArrayList(p1Map.size());
        ArrayList<Assignment> guide2 = new ArrayList(p1Map.size());

        Iterator<Map.Entry<Course, Slot>> itor = p1Map.entrySet().iterator();
        while (itor.hasNext()) {
            Map.Entry<Course, Slot> entry = itor.next();
            if (rand.nextBoolean()) {
                guide1.add(new Assignment(entry.getKey(), entry.getValue()));
                guide2.add(new Assignment(entry.getKey(), p2Map.get(entry.getKey())));
            } else {
                guide2.add(new Assignment(entry.getKey(), entry.getValue()));
                guide1.add(new Assignment(entry.getKey(), p2Map.get(entry.getKey())));
            }
        }

        Fact[] newFacts = new Fact[2];

        Fact newFact1 = (Fact) oTree.guided(guide1);
        newFact1.setEvaluation(Eval(newFact1));
        Fact newFact2 = (Fact) oTree.guided(guide2);
        newFact2.setEvaluation(Eval(newFact2));

        newFacts[0] = newFact1;
        newFacts[1] = newFact2;

        return newFacts;
    }

    //Removes the proportion of the solutions with the worst evaluations with the proportion
    //specified in killPercent.
    private void Tod(){
        int numberKilled = (int) (killPercent * facts.size());
        facts.subList(facts.size() - numberKilled, facts.size() - 1).clear();
    }

    //Evaluates how good the given solution is according to the problem soft constraints.
    private float Eval(Fact sol){
        return wMinFill*EvalMinFill(sol) + wPref*EvalPref(sol) + wPair*EvalPair(sol) + wSecDiff*EvalSecDiff(sol);
    }
    
    //Generates an evaluation score for the given fact for the course min and lab min soft constraint
    private float EvalMinFill(Fact sol){
        float pen = 0;

        Iterator<Map.Entry<Slot, Integer>> itor = sol.getNumCourses().entrySet().iterator();
        while (itor.hasNext()) {
            Map.Entry<Slot, Integer> entry = itor.next();
            if (entry.getKey().getMin() > entry.getValue()) {
                pen += pen_CourseMin;
            }
        }
        itor = sol.getNumLabs().entrySet().iterator();
        while (itor.hasNext()) {
            Map.Entry<Slot, Integer> entry = itor.next();
            if (entry.getKey().getMin() > entry.getValue()) {
                pen += pen_LabMin;
            }
        }

        return pen;
    }
    
    //Generates an evaluation score for the given fact based on the preferences
    private float EvalPref(Fact sol) {
        float pen = 0;
        HashMap<Course, Slot> schedule = sol.getScheduel();
        Iterator<Preference> itor = reader.getPreferences().iterator();

        while (itor.hasNext()) {
            Preference pref = itor.next();
            if (!pref.getSlot().equals(schedule.get(pref.getCourse()))) {
                pen += pref.getValue();
            }
        }

        return pen;
    }

    //Generates an evaluation score for the given fact based on the desired pairings
    private float EvalPair(Fact sol) {
        float pen = 0;
        HashMap<Course, Slot> schedule = sol.getScheduel();
        Iterator<Pair> itor = reader.getPairs().iterator();

        while (itor.hasNext()) {
            Pair pair = itor.next();
            if(!schedule.get(pair.getCourse(0)).equals(schedule.get(pair.getCourse(1)))) {
                pen += pen_Pair;
            }
        }

        return pen;
    }

    //Generates an evaluation score for the given fact based on the section differences soft constraint
    private float EvalSecDiff(Fact sol) {
        float pen = 0;

        ArrayList<Course> lectures = new ArrayList(reader.getCourses());
        HashMap<Course, Slot> schedule = sol.getScheduel();
        lectures.sort(new CourseSorterAlpaNum());

        Course lecture;
        while (lectures.size() > 1) {
            lecture = lectures.remove(0);
            int i = 0;
            while(i<lectures.size() && lectures.get(i).getName().equals(lecture.getName()) &&
                    lectures.get(i).getNumber().equals(lecture.getNumber() )){
                if(schedule.get(lecture).equals(schedule.get(lectures.get(i)))) {
                    pen += pen_Section;
                }
                i++;
            }
        }

        return pen;
    }

    //Calculate the Variance of the current facts and return it as a float
    private int getVariance(Fact[] newFacts){
        // Calculate first moment (mu, mean)
        firMoment = firMoment * (facts.size() - newFacts.length);
        secMoment = secMoment * (facts.size() - newFacts.length);
        for (Fact f : newFacts) {
            if (f != null) {
                firMoment += f.getEvaluation();
                secMoment += f.getEvaluation() * f.getEvaluation();
            }
        }
        firMoment = firMoment / facts.size();
        secMoment = secMoment / facts.size();

        variance = (int) (secMoment - firMoment * firMoment);

        return variance;
    }
    
    //Calculate the variance of the current state and return it as a float
    private int getVariance(){
        firMoment = 0;
        secMoment = 0;
        for (Fact f : facts) {
            firMoment += f.getEvaluation();
            secMoment += f.getEvaluation() * f.getEvaluation();
        }
        firMoment = firMoment / facts.size();
        secMoment = secMoment / facts.size();

        variance = (int) (secMoment - firMoment * firMoment);

        return variance;
    }

    //Primary method of the SetBased class. Initializes and controls the set based search.
    public Fact run()  {
        float lastEval = 0;
        System.out.println("Status: Set Based - Creating Initial Solution Set");
        for (int i = 0; i < maxInitSols; i++) {
            Fact fact = (Fact) oTree.depthFirst();
            if (fact != null) {
                fact.setEvaluation(Eval(fact));
                if (!facts.contains(fact)) {
                    facts.add(fact);
                    if (output) {
                        System.out.println("Status: Set Based - Added Initial Solution");
                    }
                }
            } else {
                return null;
            }
        }
        
        //Begins set based search
        System.out.println("Status: Set Based - Begining evolution");
        getVariance();
        Random rand = new Random();
        while (variance > threshold || facts.size() < (maxPopulation * (0.9 - killPercent))) {
            System.out.println("Variance:" + variance);
            System.out.println("Eval:" + facts.get(0).getEvaluation());
            // If facts is empty we run depthFirst
            //If facts are too big, kill them off with Tod()
            Fact newFacts[] = new Fact[2];
            if (facts.size() > maxPopulation) {
                if (output) {
                    System.out.println("Status: Set Based - Killing off the weak");
                }
                Tod();
                getVariance();
                Collections.sort(facts);
                if (abs((variance - lastEval) / variance) < difTol) {
                    break;
                }
                lastEval = variance;
            } else {    //Else randomly choose between performing a mutation or combination
                if(rand.nextBoolean()) {
                    if(output) {
                        System.out.println("Status: Mutating a pop");
                    }
                    Fact newFact = Mutation();
                    if (newFact != null) {
                        newFact.setEvaluation(Eval(newFact));
                        facts.add(newFact);
                        Collections.sort(facts);
                        newFacts[0] = newFact;
                        Collections.sort(facts);
                        System.out.println("New Eval:" + newFact.getEvaluation());
                    }
                } else {
                    if (output) {
                        System.out.println("Status: Combining two pops");
                    }
                    int i = 0;
                    for (Fact f : Combination()) {
                        if (f != null) {
                            f.setEvaluation(Eval(f));
                            facts.add(f);
                            Collections.sort(facts);
                            newFacts[i] = f;
                            i++;
                            if (output) {
                                System.out.println("New Eval:" + f.getEvaluation());
                            }
                        }
                    }
                    Collections.sort(facts);
                }
                getVariance(newFacts);
            }

        }
        return facts.remove(0);
    }
    
    //Accessor method for the current state. Returns the current state as a List of Facts.
    public List<Fact> getFacts(){return facts;}
}
