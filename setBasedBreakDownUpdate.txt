Set-Based Search Model:
    Merge courses and labs into 1 single list labCourseList.    
    Create a checkHardConstraint function that can be used by our Or-Tree program as well (protected tag is a good choice)
    (Update: On a second thought I think checkHardConstraint should be in the Or-Tree instead)

    Facts is a set of solutions [Map<CourseLabs, Slot>]. 
    Facts start as empty

    (We might need an evalList to keep track of all the Eval of Fact, or we add this value into Fact)

    Mutation() return newSolution:
        solution = Fact[random(len(Fact))]
        mut = solution.pop(random(len(solution))) 
        mut.slot = randomslot
        solution = solution.add(0,mut)
        newsolution = ortree.guided(solution)
        return newsolution
        
    Combination(random(Fact), random(Fact)) return [newSolution1, newSolution2]:
        //creating solutionA1 != solutionA2 
        solutionA1 = Fact[random(len(Fact))]
        solutionA2 = Fact[random(len(Fact))]
        while solution1 == solution2:
            solution2 = Fact[random(len(Fact))]
        //Generate guides
        solutionG1 = solutionA1[0:len(solutionA1)/2]+solutionA2[len(solutionA1)/2:]
        solutionG2 = solutionA2[0:len(solutionA1)/2]+solutionA1[len(solutionA1)/2:]
        //Run ortree
        return [ortree.guided(solutionG1),ortree.guided(soluitonG2)]
    
    Tod(A):
        numberKilled = killpercent * currentSetLength
        newFactLength = len(Fact) - numberKilled
        while len(Fact) > newFactLength:
            Fact.remove(highestEvalSolution)

    Create an Eval function to calculate the soft constraint 

Set-Based Search Control:
    maxPopulation 
    killpercent
    threshold

    while True:
        //If we don't have any solution, run depthFirst()
        if Fact.isEmpty():
            Or-Tree.depthFirst()
        else:
            //If we have too many solution, kill of some solution
            if len(Fact) > maxPopulation:
                Tod()
            else: 
                //Randomly choosing between Mutation and Combination
                Random k = random(1-2)
                if k == 1:
                    //Mutation return a newSolution that already satisfied the hard constraint checked in Or-Tree
                    newSolution = Mutation()
                    //Add new solutions
                    Fact.add(newSolution)     
                else:
                    //Combination return a list [newSolutionB1, newSolutionB2]
                    newSolution [] = Combination()
                    //Add new solutions
                    for i in range(newSolution):
                        Fact.add(newSolution[i])
        //Exit the loop if V(eval(s)) <= threshold
        if V(eval(s)) <= threshold:
            break 
    return Fact


